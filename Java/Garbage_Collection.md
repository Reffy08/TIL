# 가비지컬렉션(Garbage Collection)

프로그램이 동적으로 할당했던 메모리 영역(Heap 메모리) 중 필요 없게 된 영역을 해제 시켜주기 위해서 사용한다.    
메모리 누수를 방지할 수 있고, 해제된 메모리에 대한 접근이나 해제된 메모리에 다시 접근하는 것을 방지할 수 있다.  
하지만 GC작업은 순수한 오버헤드이며. 개발자가 언제 GC가 메모리를 해제하는지 알 수 없다.  
<br/>
<br/>

## GC 알고리즘

### Reference Counting

heap영역에 선언된 객체들이 reference count를 가지며 reference count는 해당 객체에 접근할 수 있는 방법인데 rc가 0에 도달하면 가비지 컬렉터의 대상이 된다.  

순환참조가 일어날 때 rc가 1로 유지되게 때문에 memory leak이 발생하는 문제가 있다.  

<br/>


### **Mark And Sweep**

Root Space에서부터 해당 객체에 접근 가능한지를 기준으로 삼는다.  

- Mark: 그래프 순회를 통해 접근 가능한지를 찾아냄  
- Sweep: 연결이 끊어진 객체는 지우는 방식  
- Reachable: 루트로부터 연결된 객체  
- Unreachable: 루트로부터 끊어진 객체

<br/>

#### **Mark 단계**
- 이 단계에서는 현재 사용 중인 객체를 탐색합니다.
- GC 루트(예: 스택 변수, 정적 변수 등)에서 시작하여, 각 객체의 참조를 따라가면서 도달 가능한 모든 객체를 "표시"합니다.
- 이 과정에서 참조된 객체는 "사용 중"으로 간주되고, 그 객체에 대한 표시를 합니다.

<br/>

#### **Sweep 단계**
- 이 단계에서는 메모리에서 모든 객체를 검사합니다.
- Mark 단계에서 표시되지 않은 객체는 더 이상 사용되지 않는 것으로 간주되어, 메모리에서 삭제됩니다.
- 즉, 사용자가 참조할 수 없는 객체를 메모리에서 해제하여 가비지를 수거합니다.

<br/>

### 순환 참조 문제 해결
순환 참조 문제는 두 개 이상의 객체가 서로를 참조하는 경우 발생한다. 마크 앤 스윕 알고리즘에서는 루트 객체에서 시작해 모든 접근 가능한 객체를 마크하기 때문에, 순환 참조가 있는 경우에도 문제가 없다. 왜냐하면 루트 객체에서 접근할 수 없는 객체들은 마크되지 않기 때문이다. 따라서 이러한 객체들은 스윕 단계에서 제거될 수 있다.  

결론적으로, 마크 앤 스윕 알고리즘은 자바에서 가비지 컬렉션을 수행하는 중요한 방법으로, 메모리 누수를 방지하고 효율적인 메모리 관리를 가능하게 한다.

<br/>

### Root Space

자바 가비지 컬렉션에서 Root Space는 가비지 컬렉터가 관리하는 객체의 시작점을 의미한다.
<br/>

- 스택 프레임: 현재 실행 중인 메소드의 지역 변수와 매개변수.
- 정적 변수: 클래스의 정적 필드로, 프로그램이 실행되는 동안 언제든지 접근할 수 있다.
- JNI 참조: 자바 네이티브 인터페이스를 통해 C/C++ 코드로부터 참조되는 객체.
- 쓰레드: 현재 실행 중인 모든 쓰레드가 가지고 있는 참조.
<br/>
<br/>

## GC 순서 - Heap영역

![가비지컬렉션](https://user-images.githubusercontent.com/95058915/208910038-3a4402ef-f89f-4345-895e-b7c8ec84df1e.png)

- Heap영역은 Young Generation과 Old Generation으로 나뉜다.  
- YG는 Eden영역과 Survival0 Survival1로 나뉜다.  
- YG에서 일어나는 GC를 Minor GC라고 한다.   
- OG에서 발생하는 GC를 Major GC라고 한다.  
- Eden영역: 새롭게 생성된 객체들이 할당되는 영역  
- Survival영역: Minor GC로부터 살아남은 객체가 존재하는 영역  
- Survival영역의 규칙이 있는데 Survival1, 2중 하나의 영역은 비워져있어야 한다.  

<br/>
<br/>

### 동작 순서

1. 새로운 객체가 생성되다보면 Eden영역이 꽉차는 순간이 오는데 이때 Minor GC가 일어나고 Mark And Sweep이 진행된다.  
2. Root로부터 Reachable로 판단된 객체는 Survival1으로 옮겨지고 Unreachable로 판단된 객체는 GC의 정리 대상이된다.  
3. S1으로 옮겨진 객체들의 age-bit가 0에서 1로 증가한다.  
4. 다시 시간이 지남에 따라 Eden영역이 꽉차면 Minor GC가 발생되고 Recahable이라고 판단된 객체들이 S2영역으로 이동한다.(이전 S1의 영역에 있던 객체도 함께 이동)  
5. 이렇게 계속 진행되며 age-bit가 일정 수준을 넘어가면 오래 참조된 객체로 판단되어 Old Generation으로 이동(Promotion)시킨다.  
\[ 자바8 기준 age-bit가 15일 때 Promotion 진행 \]
6. 다시 Eden영역에서부터 같은 방법으로 진행되면서 OG가 꽉차는 순간이 오면 Major GC가 발생하면서 Mark And Sweep방식을 통해서 필요없는 메모리를 비우게 된다.  
<br/>

Major GC는 Minor GC보다 오랜시간이 소요된다.  
YG와 OG를 나눈이유는 GC 설계자들이 어플리케이션을 분석해보니 대부분의 객체가 수명이 짧다는 것을 알게되고, GC도 비용이 드는데 메모리의 특정 부분만을 탐색하면서 해제하면 효율적이기 때문에 대다수의 객체는 금방 사라지므로 최대한 YG에서 해결하도록 한 것이다.  
<br/>

### Stop The World

JVM이 GC를 실행하기 위해서 어플리케이션 실행을 멈추는 것  
<br/>
<br/>

## GC 방식

### Serial GC

- 하나의 쓰레드로 GC를 실행한다.  
- Stop The World 시간이 길다.  
- 싱글 쓰레드 환경 및 Heap이 매우 작을 때 사용한다.  
<br/>

### Parallel GC

- 여러개의 쓰레드로 GC를 실행한다.  
- 멀티코어 환경에서 사용한다.  
- Java 8의 기본 GC 방식이다.  
<br/>

### CMS GC

- Stop The World 최소화를 위해 연구되어 만들어졌다.  
- GC 작업을 어플리케이션과 동시에 실행한다.  
- G1 GC등장에 따라 Deprecated됐다.  
<br/>

### G1 GC

Java 9부터 기본 GC 방식이다.  
힙을 일정 크기의 Region으로 잘게 나누어서 어떤 영역은 YG 어떤 영역은 OG로 사용한다. 
<br/>

#### Garbage First (G1)
G1 GC는 "Garbage-First"라는 이름에서 알 수 있듯이, 가비지가 가장 많이 발생하는 영역을 우선적으로 수집한다. 이를 통해 메모리 회수의 효율성을 높이고, 전체적인 응답 시간을 줄이는 데 기여한다.
<br/>

#### 힙 메모리 구조
G1 GC는 힙 메모리를 여러 개의 작은 영역(region)으로 나눈다. 각 영역은 Young 영역과 Old 영역으로 구분되며, 객체의 생애 주기에 따라 적절한 영역으로 이동된다. Young 영역에서는 새로 생성된 객체가 저장되고, Old 영역에서는 오래된 객체가 저장된다.
<br/>

#### 중단 점 최소화
G1 GC는 애플리케이션의 중단 시간을 최소화하도록 설계되었다. 이를 위해, 가비지 수집 중에 애플리케이션의 실행을 일시 중지하는 시간을 조절할 수 있다. 개발자는 중단 시간의 최대치를 설정할 수 있으며, G1 GC는 이 값에 맞추어 가비지 수집을 수행한다.
<br/>

#### 예측 가능한 성능
G1 GC는 예측 가능한 성능을 제공하기 위해 설계되었다. 이는 대규모 애플리케이션에서 안정적인 성능을 유지하는 데 도움이 된다. G1 GC는 향후 가비지 수집의 영향을 미리 예측하고, 이를 기반으로 최적의 수집 전략을 선택한다.
<br/>

#### 병렬 및 동시 수집
G1 GC는 여러 스레드를 사용하여 가비지 수집을 병렬로 수행할 수 있다. 이를 통해 수집 속도를 높이고, 전체적인 성능을 개선할 수 있다. 또한, 애플리케이션의 실행과 가비지 수집을 동시에 진행할 수 있어, 중단 시간을 더욱 줄일 수 있다.
<br/>

#### 객체 이동
G1 GC는 객체의 이동을 지원함으로써 메모리 단편화를 줄인다. 객체가 Young 영역에서 Old 영역으로 승격될 때, 해당 객체는 새로운 위치로 이동되어 저장된다. 이 과정은 가비지 수집의 일환으로 처리된다.

<br/>
<br/>


## 참조
- [https://d2.naver.com/helloworld/1329](https://d2.naver.com/helloworld/1329)
