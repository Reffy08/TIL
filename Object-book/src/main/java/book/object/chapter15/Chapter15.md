# 디자인 패턴과 프레임워크

소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴이라고 부른다.  
디자인 패턴의 목적은 설계를 재사용하는 것이다. 
디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음이다.  

프레임워크는 설계와 코드를 함께 재사용하기 위한 것이다.  
프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.  

디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공하고, 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.  

디자인 패턴, 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다.  
<br/>
<br/>

## 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

패턴의 핵심적인 특징  
- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.  
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.  
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.  

<br/>

> 내가 사용하는 패턴의 정의는 하나의 실무 컨텍스트에서 유용하게 사용해 왔고, 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어다.  - 마틴 파울러

<br/>

위 규칙에 따르면 최소 세 가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있다.  

패턴이 지닌 가장 큰 가치는 경헙을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.  

패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 '이름'이다.  

패턴은 홀로 존재하지 않고, 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 더 작은 패턴에 의해 서술될 수 있고, 패턴들을 포함하는 더 큰 패턴 내에 통합될 수 있다.  

크리스토퍼 알렉산더는 연관된 패턴들의 집합들이 모여 하나의 패턴 언어를 구성한다고 정의하고 있다.  
패턴 언어는 연관된 패턴 카테고리뿐만 아니라 패턴의 생성 규칙과 함께 패턴 언어에 속한 다른 패턴과의 관계 및 협력 규칙을 포함한다.  
<br/>

### 패턴 분류
배턴을 분류하는 일반적인 방법은 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패터느 디자인 패터느 이디엄의 4가지로 분류하는 것이다.  

디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다.  
디자인 패턴은 중간 규모의 패턴으로, 특정한 설꼐 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.  

디자인 패턴 상위에는 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 아키텍처 패턴이 위치한다.  
아키텍처 패턴은 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브 시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.  
아키텍처 패턴은 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.  

디자인 패턴 하위에는 이디엄이 위치한다.  
이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로, 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.  
이디엄은 언어에 종속적이다.  

아키텍처 패턴, 디자인 패턴, 이디엄이 주로 기술적인 문제(반드시 그렇진 않음)를 해결하는데 초점을 맞추고 있다면 분석 패턴은 도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘다.  
분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
분석 패턴은 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수 도 있다.  
<br/>

### 패턴과 책임-주도 설꼐
객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일이다.  
책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 들의 다양한 요소들의 트레이드오프를 통해 결정된다.  

패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.  
패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.  
STRATEGY 패턴은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다.  
BRIDGE 패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다.  
OBSERVER 패턴은 유연한 통지 매커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.  
<br/>

### 캡슗화와 디자인 패턴
변경하지 않는 부분은 부모 클래스로, 변하는 부분은 자식 클래스로 분리함으로써 변경을 캡슐화하고 알고리즘을 캡슐화하기 위해 합성 관계가 아닌 상속 관계를 사용하는 것을 템플릿 메서드 패턴이라고 부른다.  

추상 클래스나 인터페이스를 사용해 변경을 캡슐화하는 합성과 달리 상속을 사용할 경우에는 추상 메서드를 이용해 변경을 캡슐화해야 한다.  

템플릿 메서드 패턴은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다.  
다만 합성보다는 결합도가 높은 상속을 사용했기 때문에 전략 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다.  
하지만 알고리즘 교체와 같은 요구사항이 없다면 상대적으로 전략 패턴보다 복잡도를 낮출 수 있다는 면에서는 장점이라고 할 수 있다.  

데코레이터 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 설꼐 패턴으로서 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다.  
데코레이터 패턴은 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화할 수 있다.  

COMPOSIT 패턴은 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화하는 것이 목적이다.  
<br/>

### 패턴은 출발점이다  
패턴은 출발점이지 목적지가 아니다. 적절한 디자인 패턴을 이용해 설계를 시작한다.  
디자인 패턴이 현재의 요구사항이나 적용 기수르 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.  
 
정당한 이유 없이 사용된 모든 패턴은 설꼐를 복잡하게 만드는 장애물이다.  
패턴을 적용할 때는 상항 설계를 좀 더 단순하고 명확하게 마들 수 있는 방법이 없는지를 고민해야 한다.  
<br/>
<br/>

## 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용
재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다. 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.  

프레임워크란 '추상 클래스나 인터페이스를 정의하고 인스턴스 아이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계' 또는 '애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션 골격'을 의미한다.  
첫 번째 정의가 프레임워크의 구조적인 측면에 초점을 맞추고 있다면 두 번째 정의는 코드와 설꼐의 재사용이라는 프레임워크의 사용 목적에 초점을 맞춘다.  

프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.  
프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.  
또한 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 저공한다.  

> 프레임워크는 클래스와 객체들의 분할, 전체 구조, 클래스와 객체들 간의 상호작용, 객체와 클래스 조합 방법, 제어 흐름에 대해 미리 정의한다.  

<br/>

