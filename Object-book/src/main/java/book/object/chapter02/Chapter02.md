# 객체지향 프로그래밍

## 예제 코드 : 온라인 영화 예매 시스템 
- 영화: 영화에 대한 기본 정보 표시(제목, 상영시간, 가격 정보 등)
- 상영: 실제로 관객들이 영화를 관람하는 사건을 표현(상영일자, 시간, 순번)
- 특정한 조건을 만족하는 예매자는 요금을 할인받을 수 있다. 할인 조건(discount condition), 할인 정책(discount policy)
- 할인 조건은 가격의 할인 여부를 결정하며, 할인 정책은 할인 요금을 결정한다.
- 할인 조건은 상영 순번을 이용해 할인 여부를 결정하는 순서 조건, 상영 시작 시간을 이용해 할인 여부를 결정하는 기간 조건이 있다. 
- 할인 정책은 일정한 금액을 할인해주는 금액 할인 정책, 일정한 비율에 따라 할인 요금을 결정하는 비율 할인 정책이 있다.
- 영화별로 하나의 할인 정책만 할당할 수 있고, 지정하지 않을 수도 있다.  
<br/>

## 객체지향 프로그래밍 하기
객체지향 언어에 익숙한 사람이라면 가장 먼저 어떤 클래스가 필요한지 고민할 것이다.  

객체지향 프로그래밍하는 동안 두 가지에 집중해야 한다.
- 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라. (어떤 상태와 행동을 가지는가)
- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

### 도메인의 구조를 따르는 프로그램 구조
도메인(domain)이란 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 말한다.  

객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다.
<br/>

### 클래스 구현
외부에서는 객체의 속성에 직접 접근할 수 없도록 막고, 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야한다.  
이처럼 클래스를 구현할 때 내부와 외부를 구분해야 한다. 경계의 명확성이 객체의 자율성을 보장하며, 프로그래머에게 구현의 자유를 제공하기 때문이다.  
<br/>

객체에 대해 알아야 하는 사실
- 객체가 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재라는 것.
- 객체가 스스로 판단하고 행동하는 자율적인 존재라는 것.  
<br/>

객체지향 프로그래밍에서는 객체라는 단위 안에 데이터와 기능을 객체 내부로 함꼐 묶는다(캡슐화).  
나가아서 접근 제어(access control) 메커니즘도 제공한다. public, private, protected 등의 접근 수정자(access modifier)를 제공한다.  
<br/>

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 
외부에서 접근 가능한 부분(퍼블릭 인터페이스, Public Interface)과 오직 내부에서만 접근 가능한 부분(구현, Implementation)으로 나뉘게 된다.  
인터페이스와 구현의 분리 원칙은 좋은 객체지향 프로그래밍 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.  
<br/>

객체지향 언어에서 접근 제어를 통해 변경될 가능성이 있는 세부적인 구현 내용을 private 영역 안에 감춤으로써 변경으로 인한 혼란을 최소화할 수 있다.
<br/>

### 협력 
객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.  
<br/>

객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(request)할 수 있다. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다.  

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것뿐이다.  
다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 이야기한다.  
메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정하고, 메시지를 처리하는 자신만의 방법을 메서드(method)라고 한다.  
<br/>

### Template Method 패턴
부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴
<br/>
<br/>

## 상속과 다형성
Movie 쿨래스는 DiscountPolicy 클래스와 연결되어 있고 런타임에 DiscountPolicy 추상 클래스를 구현한 인스턴스를 의존하게 된다.  
Movie 클래스의 인스턴스를 생성하는 코드를 보면 DisCountPolicy 객체를 인자로 받는 것이 아닌 추상 클래스를 상속받아 구현한 인스턴스를 인자로 받는 것을 확인할 수 있다.

```java
Movie avatar = new Movie(
                "아바타",
                Duration.ofMinutes(120),
                Money.wons(10000),
                new AmountDiscountPolicy(Money.wons(800),
                        new SequenceCondition(1)
                )
        );
```  
<br/>

Movie의 avatar 인스턴스는 런타임에 DiscountPolicy를 상속받은 구현체에 의존하게 된다.  

이처럼 코드에서의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 즉, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.  
그리고 유연하고, 쉽게 재사용할 수 있으며 확장 가능한 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.  

코드 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기는 어려워지지만, 코드는 더욱 유연해지고 확장 가능해진다.  
<br/>

### 상속
상속은 추가하고자 하는 클래스가 기존의 클래스와 매우 흡사할 때 기존 코드를 재사용하기 위해 널리 사용되는 방법이다.  

자식 클래스는 부모클래스가 가지는 모든 속성과 메서드를 그대로 물려받을 수 있다. 또한 부모 클래스의 구현은 공유하면서 행동이 다른 자식 클래스를 췹게 추가할 수 있다.  

부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍(programming by difference)라 한다.  
<br/>

### 상속과 인터페이스
상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.  

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하자.  

자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에 부모 클래스 대신 사용될 수 있다.  

자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 한다.  
<br/>

### 다형성 
Movie 클래스는 calculateMovieFee()를 통해 DiscountPolicy에 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 다형성이라고 한다.  

다형성은 객체 지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로, 이 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.  
  
다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다륵게 응답할 수 있는 능력을 의미한다. 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.  

컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early binding) 또는 정적 바인딩(static binding)이라고 한다.  
다형성은 메시지와 메서드를 실행 시점에 바인딩한다고 하여 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다.  
<br/>
<br/>

## 추상화와 유연성
추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.  

할인 정책이 없는 경우 NoneDiscountPolicy 클래스를 추가해서 애플리케이션의 기능을 확장했다.  
추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있다.  
<br/>

### 코드 재사용
상속은 코드를 재사용하기 위해 널리 사용되는 방법인데, 객체지향 설계와 관련된 자료를 본 사람들은 코드 재사용을 위해 상속보다는 합성(composition)이 더 좋은 방법이라는 이야기를 들었을 것이다.  
합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.  

상속은 두 가지 관점에서 설계에 안좋은 영향을 미친다.  

첫 번째 문제는 캡슐화를 위반한다는 것이이다. 상속을 이용하려면 부모 클래스의 내부 구조를 잘 알아야 한다.   

두 번째 문제는 설계를 유연하게 못하게 만든다는 것이다. 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 런타임에 객체의 종류를 변경할 수 없어진다.  
<br/>  

### 합성 
step02에서 Movie가 DiscountPolicy 인터페이스를 통해 약하게 결합되어 calculateDiscountAmount 메서드를 제공한다는 사실만알고 내부 구현에 대해서는 모르게 된다.  
이처럼 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 한다.  

합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.  
인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 할 수 있다.  
또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 구현을 효과적으로 캡슐화할 수 있다.  

상속은 클래스를 통해 강결합되는 반면 합성은 메시지를 통해 느슨하게 결합된다.  
상속보다 합성을 선호하는 것이 옳지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용해야 한다.  
