# 일관성 있는 협력

객체지향 설계의 목표는 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용이 가능한 구조를 창조하는 것이다.  

객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다. 
재사용을 위해서는 객체들의 협력 방식을 일관성있게 만들어야 한다.  
일관성은 설계에 드는 비용을 감소시킨다. 
일관성은 특정한 문제를 유사한 방법으로 해결하고 있다는 사실을 알게되어 코드의 구조를 쉽게 이해할 수 있게 해준다.  

## 핸드폰 과금 시스템 변경하기

### 기본 정책 확장

유형 | 형식 | 예
:-----|:---------|:---------
고정 요금 방식|A초당 B원|10초당 8원
시간대별 방식|A시부터 B시까지 C초당 D원<br/>B시부터 C시까지 C초당 E원|00시부터 19시까지 10초당 18원<br/>19시부터 24시까지 10초당 15원
요일별 방식|평일에는 A초당 B원<br/>공휴일에는 A초당 C원|평일에는 10초당 38원<br/>공휴일에는 10초당 19원
구간별 방식|초기 A분 동안 B초당 C원<br/>A분 ~ D분까지 B초당 D원<br/>D분 초과 시 B초당 E원|초기 1분 동안 10초당 50원<br/>초기 1분 이후 10초당 20원

<br/>

#### 고정요금 방식
일정 시간 단위로 동일한 요금을 부과하는 방식이다. 
모든 통화에 대해 동일하게 10초당 9원을 부과하는 방식이고 고정 요금 방식의 예에 해당한다. 
기존의 '일반 요금제'와 동일하다.

#### 시간대별 방식
하루 24시간을 특정한 시간 구간으로 나눈 후 각 구간별로 서로 다른 요금을 부과하는 방식이다. 
예를 들어, 0시 ~ 19시까지는 10초당 18원을, 19시부터 24시까지는 10초당 15원의 요금을 부과하는 방식이다. 
기존의 '심야 할인 요금제'는 밤 10시를 기준으로 요금을 부과한 시간대별 방식이다.  

#### 요일별 방식
요일별로 요금을 차등 부과하는 방식이다. 
이 방식을 사용하면 월요일부터 금요일까지는 10초당 38원을, 토요일과 일요일에는 10초당 19원을 부과하는 요금제를 만들 수 있다.  

#### 구간별 방식
전체 동화 시간을 일정한 통화 시간에 따라 나누고 각 구간별로 요금을 차등 부과하는 방식이다. 
예를 들어, 통화 구간을 초기 1분과 1분 이후로 나눈 후 초기 1분 동안은 10초당 50원을, 그 이후에는 10초당 20원을 부과하는 방식이 구간별 방식에 해당한다. 
만약 어떤 사용자의 전체 통화 시간이 60분이라면 처음 1분에 대해서는 10초당 50원이 부과되고 나머지 59분에 대해서는 10초당 20원의 요금을 부과될 것이다.  
<br/>

### 고정요금 방식 구현하기 (step01)
기존의 일반요금제와 동일하다.  
<br/>

### 시간대별 방식 구현하기
통화 기간을 정해진 시간대별로 나눈 후 각 시간대밸로 서로 다른 계산 규칙을 적용해야 한다.  
시간대별 방식의 통화 요금을 계산하기 위해서는 통화의 시작 시간과 종료 시간뿐만 아니라 시작 일자와 종료 일자도 함께 고려해야 한다.

규칙에 따라 시간을 분할하는 방법을 결정하기 위해, 기간을 편하게 관리할 수 있는 DateTimeInterval 클래스를 추가한다.

요금 계산 로직 단계
- 통화 기간을 일자별로 분리한다.  
- 일자별로 분리된 기간을 다시 시간대별 규칙에 따라 분리한 후 각 기간에 대해 요금을 계산한다.      
<br/>

TimeOfDayDiscountPolicy 클래스에서 가장 중요한 것은 시간에 따라 서로다른 요금 규칙을 정의하는 방법을 결정하는 것이다.  
<br/>

### 요일별 방식 구현하기
요일의 목록, 단위 시간, 단위 요금이라는 세 가지 요소로 구성된다.  
<br/>

### 구간별 방식 구현하기
유사한 기능은 서로 다른 방식으로 구현해서는 안된다.  
일관성 없는 설꼐와 마주한 개발자는 여러가지 해결 방법 중에서 현재의 요구사항을 해결하기에 가장 적절한 방법을 찾아야 하는 부담을 안게 된다.  

유사한 기능을 유사한 방식으로 구현하는 방법은 협력을 일관성 있게 만들어야 한다.  

DurationDiscountPolicy 클래스는 기본 정책을 구현하는 기존 클래스들과 일관성이 없기 때문에 훌륭한 설계라 할 수 없다.  
<br/>
<br/>

## 설계에 일관성 부여하기 (step02)

#### 일관성 있는 설꼐를 만드 데 필요한 조언  
- 다양한 설계 경험을 익혀라
- 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 봐라  
<br/>

#### 협력을 일관성 있게 만들기 위한 지침  
- 변하는 개념을 변하지 않는 개념으로부터 분리하라
- 변하는 개념을 캡슐화하라  
<br/>

### 조건 로직 대 객체 탐색
조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 더 작은 클래스들로 분리해야 한다.  
클래스를 분리하기 위한 기준은 변경의 이유와 주기다.  
명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경되야 한다. 즉, 단일 책임 원칙을 따르도록 클래스를 분리해야 한다.  

추상화에 대한 의존은 결합도를 낮추고 겱과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다. 
따라서 추상화의 품질이 캡슐화의 품질을 결정한다.  
<br/>

### 캡슐화 다시 살펴보기
객체의 캡슐화는 반사적으로 데이터 은닉을 떠올리게 된다.  
데이터 은닉이란 오직 외부에 공개된 메서드를 통해서만 객체의 내부에 접근할 수 있게 제한함으로써 객체의 내부 상태 구현을 숨기는 기법을 가리킨다.  

하지만 캡슐화는 데이터 은닉 이상이다.  
GOF의 조언에 따르면 캡슐화란 단순히 데이터를 감추는 것이 아닌 소프트웨어 안에서 변할 수 잇는 모든 '개념'을 감추는 것이다. 

#### 데이터 캡슐화  
Movie 클래스의 인스턴스 변수 title의 가시은 private이기 때문에 외부에서 직접 접근할 수 없다.  
이 데이터 속성에 접근할 수 있는 유일한 방법은 메서드를 이용하는 것뿐이다.  
다시말해 클래스는 내부에 관리하는 데이터를 캡슐화한다.  

#### 메서드 캡슐화  
DiscountPolicy 클래스에서 정의돼 있는 getDiscountAmount 메서드의 가시성은 protected다.  
클래스의 외부에서는 이 메ㅓㅅ드에 직접 접근할 수 없고 클래스 내부와 서브클래스에서만 접근이 가능하다.  
따라서 클래스 외부에 영향을 미치지 않고 메서드를 수정할 수 있다. 다시 말해 클래스의 내부 행동을 캡슈로하 하고 있는 것이다.  

#### 객체 캡슐화
Movie 클래스는 DiscountPolicy 타입의 인스턴스 변수 discountPolicy를 포함한다.  
이 인스턴스 변수는 private 가시성을 가지기 때문에 Movie와 DiscountPolicy 사이의 관계룰 변경하더라도 외부에는 영향을 미치지 않는다.  
다시 말해서 객체와 객체 사이의 관계를 캡슐화한다. 객체 캡슐화는 합성임을 알 수 있다.  

#### 서브타입 캡슐화
Movie는 DiscountPolicy에 대해서는 알고 있지만 AmountDiscountPolicy와 PercentDiscountPolicy에 대해서는 알지 못한다.  
그러나 실제로 실행 시점에는 이 클래스들의 인스턴스와 협력할 수 있다.  
이것은 기반 클래스인 DiscountPolicy와 추상적인 관계가 AmountPolicy와 PercentDiscountPolicy의 존재를 감추고 있기 때문이다.  
다시 말해 서브타입의 종류를 캡슐화하고 있는 것이다.  서브타입 캡슐화는 다형성의 기반이 된다.  

서브타입, 객체 캡슐화를 적용하는 방법은 변하는 부분을 분리해서 타입 계층을 만들고, 변하지 않는 부분의 일부로 타입 계층을 합성하면 된다.  
<br/>
<br/>

## 일관성 있는 기본 정책 구현하기 (step02)

### 변경 분리하기
일관성 있는 협력을 만들기 위한 첫 번째 단계는 변하는 개념과 변하지 않는 개념을 분리하는 것이다.  

유형 | 예 | 규칙
:-----|:---------|:---------
고정 요금 방식|10초당 18원|[단위시간]당 [요금]원
시간대별 방식|00시 ~ 19시까지 10초당 18원<br/>19시 ~ 24시까지 10초당 15원|[시작시간]~[종료시간]까지<br/>[단위시간]당[요금]원
요일별 방식|평일에는 10초당 38원<br/>공휴일에는 10초당 19원|[요일]별<br/>[단위시간]당[요금]원
구간별 방식|초기 1분 동안 1분당 50원<br/>초기 1분 이후 10초당 20원|[통화구간] 동안<br/>[단위시간]당[요금]원

<br/>

단위요금은 단위시간당 요금 정보를 의미한다. 
적용조건은 통화 요금을 계산하는 조건을 의미한다.  
단위요금과 적용조건이 모여 하나의 규칙을 구성한다.  
<br/>

### 변경 캡슐화하기
협력을 일관성 있게 만들기 위해서는 변경을 캡슐화해서 파급효과를 줄여야 한다.  
방법은 변하는 부분으 공통점을 추상화하고, 변하지 않는 부분을 변하는 부분으로부터 분리하는 것이다.  

변하지 않는 것은 '규칙', 변하는 것은 '적용조건'이다.  
<br/>

### 협력 패턴 설계하기
추상화만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있게 된다. 
재사용 가능한 협력 패턴이 선명하게 드러나게 된다.  
<br/>

### 패턴을 찾아라
일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것이다.  
변경을 캡슐화하는 방법이 협력에 참여하는 객체들의 역할과 책임을 결정하고 이렇게 결정된 협력이 코드의 구조를 결정한다.  
따라서 훌륭한 설계자가 되는 첫걸음은 변경의 방향을 파악할 수 잇는 날카로운 감각을 기르는 것이다.  
그리고 이 변경에 탄력적으로 대응할 수 있는 다양한 캡슐화 방법과 설꼐 방법을 익히는 것 역시 중요하다.  

애플레키이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후, 이 추상화에 변하지 않는 공통적인 책임을 할당하라.  
현재의 구조가 변경을 캡슐화하기 적합하지 않다면 코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 협력과 코드를 리팩토링하라.  
변경을 수용할 수 있는 적절한 역할과 책임을 찾다 보면 협력의 일관성이 서서히 윤곽을 드러낼 것이다.  

> 객체지향 설꼐는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해 나가는 작업을 반복해 나가면서 다듬어진다.

<br/>

 