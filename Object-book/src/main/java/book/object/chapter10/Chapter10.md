# 상속과 코드 재사용
객체지향에서 클래스를 재사용하는 방법은 새로운 클래스를 추가하는 것이다.  
클래스를 재사용하기 위해 새로운 클래스를 추가하는 가장 대표적인 기법이 상속이다.  
새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법을 합성이라고 부른다.
<br/>

## 상속과 중복 코드

### DRY 원칙
중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.  
프로그램의 본질은 비즈니스와 관련된 지식을 코드로 변환하는 것이다.  

중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다.  

중복 여부를 판단하는 기준은 변경에 반응하는 방식이다.   
요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다. 함께 수정할 필요가 없다면 중복이 아니다.  

신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는 효과적인 방법 중 하나는 중복을 제거하는 것이다.  
즉, DRY(Don't Repeat Yourself)를 따라야 한다. (동일한 지식을 중복하지 말라)  
<br/>

### 중복과 변경

- 한 달에 한 번씩 가입자별로 전화 요금을 계산하는 예제 작성
<br/>

중복 코드는 새로운 중복 코드를 부른다.  
중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은 새로운 중복 코드를 추가하는 것 뿐이다.  
새로운 중복 코드를 추가하는 과정에서 코드의 일관성이 무너질 위험이 항상 도사리고 있다.  
더 큰 문제는 중복 코드가 늘어날수록 애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아진다는 것이다.  
중복 코드의 양이 많아질수록 버그의 수는 증가하며 그에 비례해 코드를 변경하는 속도는 점점 느려진다.  

두 클래스 사이의 중복 코드를 제거하는 한 가지 방법은 클래스를 하나로 합치는 것이다.  
하지만 타입 코드를 사용하는 방식은 낮은 응집도와 높은 결합도라는 문제에 시달리게 된다.  

객체지향 프로그래밍 언어는 타입 코드를 사용하지 않고 중복 코드를 관리할 수 있는 효과적인 방법으로 상속을 제공한다.  
<br/>

### 상속을 이용해서 중복 코드 제거하기
상속을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다.  
이것은 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미한다.  

상속은 결합도를 높인다. 그리고 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.  
<br/>

### 강하게 결합된 Phone과 NightlyDiscountPhone
Phone 코드를 재사용하고 중복 코들르 제거하기 위해 상속을 사용했지만, 세금을 부과하는 로직을 추가하기 위해 Phone을 수정할 때 유사한 코드를 NightlyDiscountPhone에도 추가해야 했다.  
다시 말해 코드 중복을 제거하기 위해 상속을 사용했음에도 세금을 계산하는 로직을 추가하기 위해 새로운 종복 코드를 만들어야 하는 것이다.

상속을 위한 경고 1
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 겷합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.    
<br/>

상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 취약한 기반 클래스 문제라고 한다.  
<br/>

## 취약한 기반 클래스 문제
상속은 자식 클래스와 부모 클래스의 결합도를 높인다.  

부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스 문제(Fragile Base Class Problem, Brittle Base Class Problem)라고 부른다.  

취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다  
상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실을 알고 있어야 한다.  
상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.  

취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다.  
상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캢슐화를 약하시킨다.  
<br/>

### 불필요한 인터페이스 상속 문제 
Stack이 부모인 Vector를 상속받기 때문에 발생하는 문제  
- 값을 추가하는데 add(), push() 모두 사용하지만 pop() 호출 시 push()로 더한 값만 출력된다.  

<br/>
<br/>

## Phone 다시 살펴보기
취약한 기반 클래스 문제를 없엘 수는 없지만 추상화로 완화시킬 수 있다.  
<br/>

### 추상화에 의존하자 
NightlyDiscountPhone의 가장 큰 문제점은 Phone에 강결합 되어있기 때문에 Phone이 변경될 경우 함께 변경될 가능성이 높다는 것이다.  
이 문제를 해결하는 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 해야한다.  
정확하게는 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 한다.  

중복 코드를 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙
- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.  
- 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.  
<br/>

### 차이를 메서드로 추출하라 
먼저 중복 코드 안의 차이점을 별도의 메서드로 추출하자.  
calculateCallFee()라는 메서드를 추출했다.  
<br/>

### 중복 코드를 부모 클래스로 올려
목표는 모든 클래스들이 추상화에 의존하도록 만드는 것이기 때문에 추상 클래스로 구현하는 것이 적합할 것이다.  
AbstractPhone을 생성해준다.  
<br/>

### 추상화가 핵심이다 
공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가진다.  
AbstractPhone은 전체 통화 목록을 계산하는 방법이 바뀔 경우에만 변경된다. Phone은 일반 통화 한건을 계산하는 방식이 바뀔때, NightlyDiscountPhone는 심야 할인 요금제 통화 한 건을 계산하는 방식이 바뀔 경우에만 변경된다.  
세 클래스는 각각 하나의 변경 이유만을 가지기 때문에 단일 책임 원칙을 준수하여 응집도가 높다.  

Phone과 NightlyDiscountPhone은 부모 클래스에서 정의한 추상 메서드에만 의존하며 calculateCallFee가 변경되지 않는 한 부모 클래스의 내부 구현이 변경되더라도 자식 클래스는 영향을 받지 않는다. 이 설꼐는 낮은 결합도를 유지하고 있다.  

자식 클래스는 추상 메서드에 의존하기 때문에 의존-역전 원칙도 준수하며, 현재 설계는 확장에 열려 있고 변경에 닫혀있으므로 개방-폐쇄 원칙도 준수한다.  

이것들이 추상화에 의존하기 때문에 얻어지는 장점이다.  
<br/>

### 의도를 드러내는 이름 선택하기 
NightlyDiscountPhone는 심야 할인 요금제와 관련된 내용을 구현한다는 것을 명확하게 드러내지만, Phone은 무슨 의도인지 명시적으로 전달하지 못한다.  
RegularPhone으로 변경하는 것이 적절할 것이다.  
<br/>

### 세금 추가하기
세금은 모든 요금제에 공통으로 적용돼야 하는 요구사항임을 기억하자.  

추상 클래스에 세율 taxRate 인스턴스 변수를 추가했는데 자식 클래스에도 인스턴스 변수를 초기화하는 로직이 들어갔다.  
부모 클래스에 정의된 인스턴스 변수를 초기화 해야하기 때문에 부모 클래스에 추가된 인스턴스 변수는 자식 클래스의 초기화 로직에 영향을 미치게 된다.  

하지만 인스턴스 초기화 로직을 변경하는 것이 두 클래스에 동일한 세금 계한 코드를 중복시키는 것보다는 현명한 선택이다.  
객체 생성 로직의 변경을 막기보다는 핵심 로직의 중복을 막아라. 핵심 로직은 한 곳에 모아놓고 조심스럽게 캡슐화 해야한다. 그리고 공통적인 핵심 로직은 최대한 추상화 해야 한다.  

지금까지 살펴본 것처럼 상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다. 상속은 어떤 방식으로둔 부모 클래스와 자식 클래스를 결합시킨다.  
우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전체에 걸쳐 부작용이 퍼지지 않게 막는 것이다.  
<br/>
<br/>

## 차이에 의한 프로그래밍
기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 차이에 의한 프로그래밍(programming by difference)이라고 부른다.  
상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의가 가능해진다.  

차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코들르 재사용하는 것이다.  
중복 코드를 제거하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재구성 해야 한다.  
코드를 재사용하기 위해서는 중복 코드를 제거해서 하나의 모듈로 모아야 한다.  
프로그래밍 세계에서 중복 코드는 악의 근원이므로, 중복 코드를 제거하고 최대한 코드를 재사용 해야 한다.  
<br/>

