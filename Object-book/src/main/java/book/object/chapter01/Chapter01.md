# 객체, 설계

어떤 분야든 초기 단계에서는 아무것도 없는 상태에서 이론을 정립하기보다는 실무를 관찰한 결과를 바탕으로 이론을 정립하는 것이 최선이다.  
<br/>

소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적이다.  
<br/>
<br/>

## 구현할 예제 코드 : 티켓 판매 애플리케이션
- 이벤트 : 공연 무료 관람 초대장 발송  
- 이벤트 당첨 관람객과 일반 관람객 구분  
- 이벤트 당첨 관람객은 초대장을 티켓으로 교환 후 입장, 나머지는 티켓 구매 후 입장    
- 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고 이벤트 당첨자가 아닌 경우에는 티켓을 판매한 후 입장해야 한다    
<br/>


### 로버트 마틴의 소프트웨어 모듈이 가져야하는 세 가지 목적
- 실행 중에 제대로 동작하는 것
- 변경을 위해 존재하는 것
- 코드를 읽는 사람과 의사소통 하는 것  
<br/>

마틴애 따르면 모든 모듈은 제대로 실행되어야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다.  
<br/>
<br/>

## 문제점 찾아보기

### step01의 문제
관람객과 판매원이 소극장의 통제를 받는 수동적인 존재인 점이다.  
관람객의 입장에서 문제는 소극장이라는 제 3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어보는 것.    
판매원의 입장에서 문제는 소극장이 허락도 없이 매표소에 보관중인 티켓과 현금에 마음대로 접근할 수 있는 것.  
더 큰 문제는 티켓을 꺼내 관람객의 가방에 집어넣고 관란갬에게서 받은 돈을 매표소에 적립하는 일을 소극장이 수행한다는 점이다.  
<br/>

이해 가능한 코드란 그 동작이 우리의 예상과 크게 벗어나지 않는 코드이다.  
stop01의 코드는 우리의 예상을 크게 벗어난다.  
<br/>

### 변경에 취약한 코드
step01의 가장 큰 문제는 변경애 취약한 것이다.  
관람객이 가방을 들고 있지 않거나, 현금이 아닌 신용카드를 이용해서 곌제한고 할 때, 판매원이 메표소 밖에서 티켓을 판매해야 한다면 등의 가정이 깨지는 순간 모든 코드가 일시에 흔들리게 된다.  
<br/>
Theater는 지나치게 세부적인 사실에 의존해서 동작하는데, 이럴수록 코드를 변경하기 힘들어진다.  
<br/>

이것은 객체 사이의 의존성(dependency)과 관련된 문제이다. 문제는 의존성이 변광과 관련돼 있다는 점이다. 의존성읜 변경에 대한 영향을 암시한다.  
의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포되어 있다.  
<br/>

객체지향 설걔는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다.  
우리의 목표는 애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거해야 한다.  
<br/>

객체 사이의 의존성이 과한 경우를 결합도(coupling)가 높다고 말하며, 객체들이 합리적인 수준으로 의존할 경우 결합도가 낮다고 한다.  
따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경에 용이한 설계를 만드는 것이어야 한다.  
<br/>
<br/>

## step02
극장(Theater) 클래스에서의 작업을 판매원(TicketSeller)의 로직으로 이동시킨다.
TicketOffice에 캡슐화(개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것)를 통해 접근을 제한한다.  
캡슐화를 사용하면 객체와 객체 사이의 결합도를 낮춰 설계를 좀 더 쉽게 변경할 수 있게 해준다.  
<br/>

Theater 클래스의 enter 메서드 로직을 TicketSeller로 구현해서 Theater클래스에서 ticketOffice에 접근할 수 없도록 구현한다.  
Theater는 오직 TicketSeller 인터페이스에만 의존한다. TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation) 영역에 속한다.  
갹채룰 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

### 개선된 점
step02에서는 Audience와 TicketSeller는 자신이 가지고 있는 소지품을 스스로 관리한다.  
그리고 두 객체의 내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다는 점이 중요하다.  
<br/>

간단하게는 TicketSeller와 Audience 클래스 자신의 문제를 스솔 해결하도록 코드를 변경한 것이다.
<br/>

### 캡슐화와 응집도   
핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.  
밀접하게 연관된 작업만 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 말한다.  
자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.    
<br/>

객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다. 그것이 객체의 응집도를 높이는 첫 번째 걸음이다.  
<br/>

### 절차지향과 객체지향
stop01에서 Audience, TicketSeller, Bag, TicketOffice는 관람객을 입장시키는 데 필요한 정보를 제공하고 모든 처리는 Theater의 enter 메서드 안에 존재했다는 점에 주목해야 한다.  
이 관점에서 Theater의 enter 메서드는 프로세스(Process)이며 Audience, TicketSeller, Bag, TicketOffice는 데이터(Data)다.  
이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍(Procedural Programming)이라고 부른다.  

알반적으로 절차적 프로그래밍은 우리의 직관에 위배되며(우리는 관람객과 판매원이 자신의 일을 스스로 처리할 것을 예상), 우리의 예상을 쉽게 벗어나기 때문에 코드를 읽는 사람과 원할하게 의사소통하지 못한다.  
<br/>

변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.  
절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수 밖에 없다.  

이를 해결하기 위해선 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 Audience와 TicketSeller로 이동시키는 것이다.  
이처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍(Object-Oriented-Programming)이라고 한다.  

좋은 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.   
<br/>

### 책임의 이동
두 방식 사이에 근본적인 차이를 만드는 것은 책임의 이동(shift of responsibility)이다. Theater에 몰려있던 책임이 개별 객체로 이동한 것이 책임의 이동이다. 
stop01의 로직은 책임이 Theater에 집중이 되어 있으며, step02의 로직은 각 객체 자신을 스스로 책임진다.  

객체지향에서는 객체가 어떤 데이터를 가지냐보다는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞춰야 한다.  

설계를 어렵게 만드는 것은 의존성이고, 해결 방법은 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.  
step02에서는 Theater가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 캡슐화하여 객체의 자율성을 높이고 응집도를 높였다.  
<br/>
<br/>

## step03
step02의 코드에서 TicketOffiec와 Bag를 자율적으로 만들어 각 객체에 접근하는 로직을 객체 안으로 이동시켰지만 새로운 의존성이 추가되어 결합도만 높아졌다.  
트레이드 오프의 시점이 온것이다.  

예제를 통해 두 가지 사실을 알게 됐다. 첫째, 어떤 기능을 설계하는 방법은 한가지 이상일 수 있다. 둘째, 동일한 기능을 한가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.  

훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다.  
그 대상이 비록 실셰꼐에서는 생명이 없는 수동적인 존재라고 하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다.  
<br/>
<br/>

## 객채지향 설계
> 설계란 코드를 배치하는 것이다. [Metz12]  

설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결장하는 과정에서 나온다.  
우리가 짜는 프로그램은 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야 한다.  

변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다.  
그리고 코드를 변경할 때 버그가 추가될 가능성이 높기 때문이다. 요구사항 변경은 필연적으로 코드 수정을 초래하고, 코드 수정은 버그 발생 가능성을 높인다.  
<br/>

우리가 원하는 것은 변경에 유연하게 대응할 수 있는 코드이다.  
객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다.  

객체지향 패러다임은 우리가 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다. 우리가 세상에 대해 예상하는 방식대로 객체가 행동하리라는 것을 보장함으로써 코드를 좀더 쉽게 이해할 수 있게 한다.  

훌륭한 객체지향 설꼐란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다. 객체가 주변 환경에 강결합 되면 변경을 어렵게 한다.  

